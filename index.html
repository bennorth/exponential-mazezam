<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Exponential Mazezam level family</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="hugo-octopress.css" type="text/css" />
  <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
  <script src="game.js"></script>
  <link rel="stylesheet" href="level-demo.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Exponential Mazezam level family</h1>
</div>
<div class="home-link">
<p>
<a href="http://www.redfrontdoor.org/blog/">Ben North</a>, January 2017
</p>
</div>
<h2 id="background-mazezams-complexity">Background: Mazezam's complexity</h2>
<p><a href="https://sites.google.com/site/malcolmsprojects/mazezam-home-page">Mazezam</a> is a puzzle game written by Malcolm Tyrrell, and back in 2008 I constructed what I thought was <a href="http://redfrontdoor.org/blog/?p=174">an argument</a> for why this game was 'NP-complete'. This means two things:</p>
<ul>
<li>It is in NP.</li>
<li>That it is 'NP-hard', meaning that if Mazezam can be solved in polynomial time, then so can any other problem in NP.</li>
</ul>
<p>I recently received an email from <a href="https://simons-rock.edu/academics/faculty-bios/science-mathematics-and-computing-faculty/aaron-williams.php">Aaron Williams</a> pointing out that what I had actually done was show the second part only. I had not shown that Mazezam was in NP.</p>
<p>I had initially thought this part was obvious — if somebody proposes a solution to a level, just try simulating the given sequence of moves and check the hero does indeed make it to the exit. However, Aaron pointed out I had missed an important detail of the 'polynomial time verification' formulation of NP. The definition of NP, in this formulation, is given in <a href="http://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/lectures/lect0331.pdf">lectures notes</a> from <a href="http://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/">CMU's Algorithms course</a>:</p>
<blockquote>
<p>A problem is in NP if there is a polynomial-time algorithm V(I,X) such that:</p>
<ul>
<li>If I is a YES-instance, then there exists X such that V(I,X) = YES.</li>
<li>If I is a NO-instance, then for all X, V(I,X) = NO.</li>
</ul>
<p>Furthermore, X should have length polynomial in size of I (since we are really only giving V time polynomial in the size of the instance, not the combined size of the instance and solution).</p>
</blockquote>
<p>It was the '<em>X should have length polynomial in size of I</em>' part that I had overlooked. Aaron conjectured that</p>
<blockquote>
<p>the shortest series of button presses (i.e., down, right, right, up, etc.) to solve a given level could, in theory, be exponential in length with respect to the size of the puzzle.</p>
</blockquote>
<h2 id="an-exponential-level-family">An exponential level family</h2>
<p>I thought it would be interesting to try to construct a family of levels with this property. I thought that something like the Towers of Hanoi or the Chinese Rings ought to work. The <a href="http://www.springer.com/cda/content/document/cda_downloaddocument/9783034802369-c2.pdf?SGWID=0-0-45-1376234-p174195065">solution to the Chinese Rings</a> led me to the idea of forcing the player to work their way through all possible states of a Gray code counter.</p>
<p>The building blocks are similar to those in <a href="http://redfrontdoor.org/blog/?p=174">my original write-up</a>. There will be one movable row per bit in the modelled counter. The player can change each such row between a position representing '<code>0</code>' and a position representing '<code>1</code>'. However, the only changes possible will be those matching the permissible changes to a Gray code counter:</p>
<ul>
<li>The least significant bit, 'bit 0', can be changed at any time.</li>
<li>Any other bit can only be changed if the next-less-significant bit is a '<code>1</code>' and all lower-significance bits (if any) are '<code>0</code>'.</li>
</ul>
<p>Except when the counter is in its starting (<code>00...00</code>) or ending (<code>10..00</code>) state, there is always a bit position satisfying the second bullet.</p>
<p>For example, if an 8-bit counter is currently <code>01011000</code>, then the permissible changes are:</p>
<ul>
<li><code>01011000</code> → <code>01011001</code> (change least significant bit);</li>
<li><code>01011000</code> → <code>01001000</code> (change bit 4, because bit 3 is <code>1</code> and bits 2, 1, and 0 are <code>0</code>).</li>
</ul>
<p>I achieve these constraints in a Mazezam level by using the same vertical corridors as previously to enforce the requirements, joined to a modified corridor to allow the toggling.</p>
<p>The idea is best illustrated with an example.</p>
<h2 id="demo">Demo</h2>
<p>We now illustrate the scheme for a 6-bit counter.</p>
<p>The level below forces the player to go through the complete 6-bit Gray code counter from its initial state of <code>000000</code> to its final state of <code>100000</code>, at which point the player can escape out of the bottom-right. The player moves in the black areas. The light-grey rows are movable and the dark-grey rows are fixed. The bottom light row, (call it <code>b0</code>), is 'bit 0', the least-significant bit, and so on up to the top light row (<code>b5</code>), which is 'bit 5', the most-significant bit.</p>
<p>A light row in its leftward position means that bit is '<code>0</code>'; in its rightwards position means '<code>1</code>'. All rows therefore start off in their leftward position.</p>
<p>The bulk of the level is made of horizontally-stacked reflected 'J's. The long (left, 'open' at top) arm of a reflected J allows passage through it under certain conditions, but does not allow changing any rows while still being able to get to the bottom. The short (right, dead-end) arm lets you toggle one particular bit, while forcing you to leave all other bits alone. If you do toggle that bit, you can still get out the long (left) arm.</p>
<p>The 'J's are configured to embody the Gray code requirements:</p>
<p>The leftmost reflected 'J' allows you to flip <code>b0</code> at any time. The second from the left allows you to flip <code>b1</code> whenever <code>b0</code>=<code>1</code>. The third from left allows you to flip <code>b2</code> whenever <code>b1</code>=<code>1</code> and <code>b0</code>=<code>0</code>. The fourth from left lets you flip <code>b3</code> if <code>b2</code>=<code>1</code>, <code>b1</code>=<code>0</code>, and <code>b0</code>=<code>0</code>. And so on. The rightmost corridor allows you to successfully exit the level if the bit-vector is <code>100000</code>.</p>
<p>Use the <code>Start</code> button to animate the solution to the level; <code>Reset</code> to reset the level. The radio buttons control the animation's speed.</p>
<div id="game-container">
<div id="game-canvas">
<img class="game-slice" id="slice-00" src="gray-slice-00.png"> <img class="game-slice" id="slice-01" src="gray-slice-01.png"> <img class="game-slice" id="slice-02" src="gray-slice-02.png"> <img class="game-slice" id="slice-03" src="gray-slice-03.png"> <img class="game-slice" id="slice-04" src="gray-slice-04.png"> <img class="game-slice" id="slice-05" src="gray-slice-05.png"> <img class="game-slice" id="slice-06" src="gray-slice-06.png"> <img class="game-slice" id="slice-07" src="gray-slice-07.png"> <img class="game-slice" id="slice-08" src="gray-slice-08.png"> <img class="game-slice" id="slice-09" src="gray-slice-09.png"> <img class="game-slice" id="slice-10" src="gray-slice-10.png"> <img class="game-slice" id="slice-11" src="gray-slice-11.png"> <img class="game-slice" id="slice-12" src="gray-slice-12.png"> <img id="player" src="player.png">
</div>
<div id="controls">
<table>
<tr>
<td>
Counter value:
</td>
<td id="counter-value">
0 0 0 0 0 0
</td>
</tr>
<tr>
<td>
Number of moves:
</td>
<td id="n-moves">
0
</td>
</tr>
</table>
<form action>
<input type="radio" name="speed" value="slow" checked="checked">Slow <input type="radio" name="speed" value="fast">Fast <input type="radio" name="speed" value="warp">Warp
</form>
<p id="buttons">
<button id="btn-start">
Start
</button>
<button id="btn-reset">
Reset
</button>
</p>
</div>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>The scheme could be expanded to an arbitrary number of bits, with the result being a level whose width and height are both linear in the number of bits in the counter, but whose solution is exponential in the number of bits.</p>
<h2 id="source-code">Source code</h2>
<p>Available on github: <a href="https://github.com/bennorth/exponential-mazezam">bennorth/exponential-mazezam</a>.</p>
<div class="home-link">
<p>
<a href="http://www.redfrontdoor.org/blog/">Ben North</a>, January 2017
</p>
</div>
<p class="copyright-footer">
This web-page content Copyright 2017 Ben North; licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>
</p>
</div>
</body>
</html>
